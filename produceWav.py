import math
import numpy as np
import scipy
from stl import mesh

from mallotImpact import *
from subdivision import *
from lengthSolver import *
from pointCollection import *
from outsideMat import *
from diagonalMat import *
from mijMat import *


def produceWav(filename,n,youngs,mallotImpact,fs):

	"""
	Input: filename needs to be in '.stl' format ex. filename = 'sphere.stl'
		   n = the number of the times of division
		   youngs = young's modulous for the specific material
		   mallotImpact = the forcevector generated by the mallotImpact function
		   fs = frequency of sampling
	"""

	file_mesh = mesh.Mesh.from_file(filename)

	oriTriangleSet = file_mesh.vectors
	#triNormVecs = file_mesh.normals

	triangleSet = []
	triNormVecs = []

	for i in range(len(oriTriangleSet)):
		points, singleTriangleSet, singleNorVecSet = subdivision(oriTriangleSet[i][0], oriTriangleSet[i][1], oriTriangleSet[i][2],n)

		for j in range(len(singleTriangleSet)):
			triangleSet.append(singleTriangleSet[j])
			triNormVecs.append(singleNorVecSet[j])

	forceVecs = np.zeros((len(triNormVecs),3))

	for i in range(len(forceVecs)):
		forceVecs[i] = -1*triNormVecs[i]*3

	Llist, Lmat = lengthSolver(triangleSet,triNormVecs,forceVecs)

	positions = pointCollection(triangleSet)

	# This function takes in Young's modulus for different materials
	Mijmatrix = mijMat(youngs,Llist,triangleSet,positions)
	OTMat = outsideMat(positions,Mijmatrix)
	Dmat = diagonalMat(positions,Mijmatrix)

	BigMatrix = OTMat + Dmat

	# w is eigenvalues, v is unit length eigenvectors
	w, v = np.linalg.eig(BigMatrix)

	# Call mallotImpact()
	mallotImpact = mallotImpact()


	coefficients = np.linalg.lstsq(v, mallotImpact)

	# Reshape coefficients, t and eigenvalues for computation
	coefficientsComp = np.reshape(coefficients, (1,len(coefficients)))
	wComp = np.reshape(w, (1,len(w)))
	t = np.zeros((fs,1))

	for i in range(fs):
		t[i] = i/fs

	wavVector = np.sum(coefficientsComp*np.exp(1j*wComp*t), axis=1)

	# Make the wav file
	scipy.io.wavfile.write("Wavfile", fs, wavVector)