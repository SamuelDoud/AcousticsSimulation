import math
import numpy as np
import scipy.io.wavfile
from stl import mesh

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm

from chimeVelocity import *
from mallotImpact import *
from subdivision import *
from lengthSolver import *
from pointCollection import *
from outsideMat import *
from diagonalMat import *
from mijMat import *

# import winsound


def produceWav(filename,n,youngs,fs):

	"""
	Goal: Final section of the simulation. Incorporates every previous section
		  to produce the simulation of the impact sound as a wav file

	Input: filename needs to be in '.stl' format ex. filename = 'sphere.stl'
		   n = the number of the times of division
		   youngs = young's modulous for the specific material
		   mallotImpact = the forcevector generated by the mallotImpact function
		   fs = frequency of sampling (44,100)
	Output: A wav file
	"""

	file_mesh = mesh.Mesh.from_file(filename)

	oriTriangleSet = file_mesh.vectors
	#triNormVecs = file_mesh.normals

	triangleSet = []
	triNormVecs = []

	for i in range(len(oriTriangleSet)):
		points, singleTriangleSet, singleNorVecSet = subdivision(oriTriangleSet[i][0], oriTriangleSet[i][1], oriTriangleSet[i][2], n)

		for j in range(len(singleTriangleSet)):
			triangleSet.append(singleTriangleSet[j])
			triNormVecs.append(singleNorVecSet[j])

	forceVecs = np.zeros((len(triNormVecs),3))

	for i in range(len(forceVecs)):
		forceVecs[i] = -1*triNormVecs[i]*3

	Llist, Lmat = lengthSolver(triangleSet,triNormVecs,forceVecs)

	positions = pointCollection(triangleSet)

	# This function takes in Young's modulus for different materials
	Mijmatrix = mijMat(youngs,Llist,triangleSet,positions)

	"""
	# Plotting for test purposes, delete after
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')

	xs = []
	ys = []
	zs = []
	wxs = []
	wys = []
	wzs = []

	for i in range(len(positions)):
		xs.append(positions[i][0])
		ys.append(positions[i][1])
		zs.append(positions[i][2])

	ax.scatter(xs, ys, zs)
	plt.hold(True)

	for i in range(len(weirdPoints)):
		wxs.append(weirdPoints[i][0])
		wys.append(weirdPoints[i][1])
		wzs.append(weirdPoints[i][2])

	ax.scatter(wxs, wys, wzs, s=50, c="yellow")
	plt.show()
	"""


	OTMat = outsideMat(positions,Mijmatrix)
	Dmat = diagonalMat(positions,Mijmatrix)

	BigMatrix = OTMat + Dmat

	# w is eigenvalues, v is unit length eigenvectors
	w, v = np.linalg.eig(BigMatrix)

	# Call mallotImpact()

	"""
	initialImpact = np.zeros(len(positions)*3)
	initialImpact[18] = 500
	initialImpact[19] = 500
	initialImpact[20] = 500
	initialImpact[21] = 500
	initialImpact[22] = 500
	initialImpact[23] = 500
	"""
	

	#print "eigenvectors matrix shape = " + str(v.shape)
	#print "initialImpact shape = " + str(initialImpact.shape)

	v2 = chimeVelocity(0.043, 0.002, 0)
	initialImpact = mallotImpact(positions, np.array([0, .0127, .0535]), v2, .015)



	coefficients = np.linalg.lstsq(v, initialImpact)[0]
	#print "coefficients shape = " + str(coefficients.shape)


	# Reshape coefficients, t and eigenvalues for computation
	#coefficientsComp = np.reshape(coefficients, (1,len(coefficients)))
	wComp = np.reshape(w, (1,len(w)))
	t = np.zeros((fs,1))

	for i in range(fs):
		t[i] = 1.0*i/fs


	# Produce the wave vector
	wavVectorUnit = np.sum(coefficients*np.exp(1j*wComp*t), axis=1)
	wavVectorUnit1 = wavVectorUnit

	# Repeat the vector 10 times to make the final product longer (not sure if it is the right way to do it)
	for i in range(10):
		wavVector = np.concatenate((wavVectorUnit1, wavVectorUnit))
		wavVectorUnit1 = wavVector

	# Gives me an audio alert when the program finishes
	"""
	duration = 1000
	freq = 440
	winsound.Beep(freq, duration)

	print np.size(wavVector)
	#print np.dtype(wavVector)
	print np.dtype(wavVector[0])
	plt.plot(np.real(wavVector))
	plt.show()
	"""

	# Make the wav file
	scipy.io.wavfile.write("Wavfile1.wav", fs, np.int16(np.real(wavVector)))

produceWav("newChimeR.0127D4.stl",1,128*10**9,44100)